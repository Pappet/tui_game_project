## ðŸš€ PROJECT SCOPE CONFIRMED

  - **Project Goal:** A TUI-based Python game focused on hero management and progression.
  - **Initial Decisions:**
      - Use Python.
      - Must be TUI-based (Text User Interface).
      - Manage a team of 5 heroes.
      - Include an equipping system.
      - Gameplay centers on short battles.
      - Include a progression system linked to improving a "base."

-----

## ðŸ§± INITIAL PROJECT STATE

Here is the initial PROJECT STATE (v0.1) required to start the development team.

```json
{
  "version": "v0.1",
  "files": [],
  "decisions": [
    "Goal: TUI-based Python game",
    "Use Python",
    "Platform: TUI (Text User Interface)",
    "Core mechanic: Manage a team of 5 heroes",
    "Core mechanic: Equipping heroes",
    "Core mechanic: Short battles",
    "Core mechanic: Progression system tied to improving a base"
  ],
  "completion_status": {
    "architecture": "pending",
    "implementation": "not_started",
    "review": "not_started",
    "documentation": "not_started"
  },
  "next_step": {
    "agent": "DESIGN",
    "task": "Design the architecture for a TUI-based Python game. The design must accommodate a 5-hero team, equipping, short battles, and a base-building progression system. Define modules and create 'architecture.md'."
  }
}
```
=============================================================================================================================================================================================

REWRITE: architecture.md

Hallo\! Hier ist der erste Entwurf fÃ¼r die Projektarchitektur.

Die Architektur zielt auf eine klare Trennung zwischen der BenutzeroberflÃ¤che (TUI), der Spiellogik und dem Kernstatusmanagement ab. Dies erleichtert die Wartung und das Testen.

-----

# Architecture Plan (architecture.md)

## 1\. High-Level Concept

Das Projekt wird als modulare Python-Anwendung strukturiert. Der Kern der Architektur trennt die **Game Logic** (Was passiert im Spiel?) von der **TUI Presentation** (Wie wird es angezeigt?).

Ein zentraler `GameController` (oder "Game Loop") verwaltet den aktuellen Spielzustand (z.B. `MENU`, `BATTLE`, `BASE_MANAGEMENT`) und leitet Benutzereingaben an das entsprechende Logikmodul weiter.

FÃ¼r die TUI schlagen wir die Verwendung des **Textual**-Frameworks vor. Es bietet ein modernes, ereignisgesteuertes Modell, das gut zu dieser modularen Struktur passt und die Verwaltung komplexer Layouts (Basis, Team-Management, Kampf) vereinfacht.

## 2\. Directory and Module Structure

Hier ist die vorgeschlagene Verzeichnisstruktur:

```plaintext
tui_game/
â”œâ”€â”€ main.py
â”œâ”€â”€ core/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ game_controller.py  # Manages the main game loop and state transitions
â”‚   â””â”€â”€ game_state.py       # Holds all persistent data (heroes, inventory, base)
â”‚
â”œâ”€â”€ tui/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ app.py              # Textual App entry point
â”‚   â”œâ”€â”€ input_handler.py    # (May be handled by Textual events)
â”‚   â””â”€â”€ screens/
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ base_screen.py    # UI for base building and progression
â”‚       â”œâ”€â”€ battle_screen.py  # UI for combat
â”‚       â”œâ”€â”€ hero_screen.py    # UI for hero management and equipping
â”‚       â””â”€â”€ main_menu.py    # UI for the main menu
â”‚
â”œâ”€â”€ game_logic/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ base_manager.py     # Logic for base progression and unlocks
â”‚   â”œâ”€â”€ battle_system.py    # Logic for handling combat mechanics
â”‚   â”œâ”€â”€ hero_manager.py     # Logic for hero stats, leveling, and status
â”‚   â””â”€â”€ item_manager.py     # Logic for equipment, inventory, and item effects
â”‚
â”œâ”€â”€ data/
â”‚   â”œâ”€â”€ items.json          # Definitions for equippable items
â”‚   â”œâ”€â”€ heroes.json         # Definitions for hero classes/archetypes
â”‚   â””â”€â”€ enemies.json        # Definitions for battle encounters
â”‚
â””â”€â”€ utils/
    â”œâ”€â”€ __init__.py
    â””â”€â”€ logger.py           # General utility functions (e.g., logging)
```

## 3\. Module Responsibilities

### `main.py`

  * **Verantwortung:** Der Haupteinstiegspunkt der Anwendung.
  * **Aktion:** Initialisiert und startet die Textual TUI-Anwendung (`tui/app.py`).

### `core/` (Der Kern)

  * `game_controller.py`: Der "Dirigent". Wechselt zwischen den HauptzustÃ¤nden (z.B. vom `base_screen` zum `battle_screen`). Er koordiniert die Aktionen zwischen der `tui` und der `game_logic`.
  * `game_state.py`: Das "Gehirn". Beinhaltet den gesamten *persistente* Zustand des Spiels (alle Helden, ihr Inventar, der Zustand der Basis). Dieses Modul ist dafÃ¼r verantwortlich, den Spielstand zu laden und zu speichern (z.B. als JSON).

### `tui/` (Die Darstellung)

  * `app.py`: Die Haupt-Textual-Anwendungsklasse. LÃ¤dt die verschiedenen `screens`.
  * `screens/`: Jede `.py`-Datei hier reprÃ¤sentiert einen Hauptbildschirm.
      * `base_screen.py`: Zeigt die Basis an, erlaubt Interaktionen fÃ¼r Upgrades (definiert in `game_logic/base_manager.py`).
      * `hero_screen.py`: Zeigt das 5-Personen-Team an, erlaubt das AusrÃ¼sten von GegenstÃ¤nden (Logik aus `hero_manager.py` und `item_manager.py`).
      * `battle_screen.py`: Zeigt den Kampf an (Logik aus `battle_system.py`).

### `game_logic/` (Die Regeln)

  * Dies sind "dumme" (stateless) Logik-Module. Sie erhalten den `game_state` von `core/`, fÃ¼hren Berechnungen durch und geben das Ergebnis zurÃ¼ck. Sie interagieren *niemals* direkt mit der TUI.
  * `hero_manager.py`: Verwaltet das Level-Up eines Helden, berechnet Statuswerte basierend auf der AusrÃ¼stung.
  * `item_manager.py`: Definiert, was passiert, wenn ein Gegenstand ausgerÃ¼stet wird.
  * `battle_system.py`: Berechnet den Ausgang einer Angriffsrunde im Kampf.
  * `base_manager.py`: Verwaltet die Regeln und Kosten fÃ¼r Basis-Upgrades und deren Auswirkungen auf das Spiel (z.B. Freischalten neuer AusrÃ¼stung).

## 4\. Data Flow Example (Equipping an Item)

1.  **User Input:** Der Benutzer drÃ¼ckt 'E' auf einem Helden im `tui/hero_screen.py`.
2.  **TUI Event:** Der `hero_screen` (Textual Widget) fÃ¤ngt die Eingabe ab.
3.  **Action Call:** Der Screen ruft den `core/game_controller.py` auf (z.B. `controller.equip_item(hero_id, item_id)`).
4.  **Game Logic:** Der `game_controller` ruft `game_logic/item_manager.py` auf (z.B. `item_manager.apply_item(game_state, hero_id, item_id)`).
5.  **State Update:** Der `item_manager` modifiziert das `game_state`-Objekt (z.B. fÃ¼gt das Item dem Helden hinzu und entfernt es aus dem Inventar).
6.  **UI Refresh:** Der `game_controller` signalisiert der TUI (oder die TUI reagiert auf die ZustandsÃ¤nderung, z.B. via Textual "watch"), dass die Daten sich geÃ¤ndert haben.
7.  **Render:** `tui/hero_screen.py` liest den aktualisierten `game_state` und zeichnet sich neu, um das ausgerÃ¼stete Item anzuzeigen.

-----

```json
{
  "agent": "DESIGN",
  "version": "v0.1",
  "files": [
    {
      "path": "architecture.md",
      "status": "in_progress",
      "last_agent": "DESIGN"
    }
  ],
  "decisions": [
    "Goal: TUI-based Python game",
    "Use Python",
    "Platform: TUI (Text User Interface)",
    "Core mechanic: Manage a team of 5 heroes",
    "Core mechanic: Equipping heroes",
    "Core mechanic: Short battles",
    "Core mechanic: Progression system tied to improving a base",
    "Architecture: Modular (Core, TUI, Game Logic)",
    "TUI Framework Suggestion: 'textual'"
  ],
  "completion_status": {
    "architecture": "in_progress",
    "implementation": "not_started",
    "review": "not_started",
    "documentation": "not_started"
  },
  "next_step": {
    "agent": "META",
    "task": "Review the proposed architecture (architecture.md). If approved, assign BUILDER to set up the initial project structure (directories and empty __init__.py files) based on the plan."
  }
}
```

=============================================================================================================================================================================================